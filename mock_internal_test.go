// Automatically generated by MockGen. DO NOT EDIT!
// Source: /development/go-workspace/src/github.com/tkashem/fizbus/internal.go

package fizbus

import (
	gomock "github.com/golang/mock/gomock"
	amqp "github.com/streadway/amqp"
	upstream "github.com/tkashem/fizbus/upstream"
	context "golang.org/x/net/context"
)

// Mock of handler interface
type Mockhandler struct {
	ctrl     *gomock.Controller
	recorder *_MockhandlerRecorder
}

// Recorder for Mockhandler (not exported)
type _MockhandlerRecorder struct {
	mock *Mockhandler
}

func NewMockhandler(ctrl *gomock.Controller) *Mockhandler {
	mock := &Mockhandler{ctrl: ctrl}
	mock.recorder = &_MockhandlerRecorder{mock}
	return mock
}

func (_m *Mockhandler) EXPECT() *_MockhandlerRecorder {
	return _m.recorder
}

func (_m *Mockhandler) Handle(c context.Context, d amqp.Delivery) {
	_m.ctrl.Call(_m, "Handle", c, d)
}

func (_mr *_MockhandlerRecorder) Handle(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Handle", arg0, arg1)
}

// Mock of errorChannel interface
type MockerrorChannel struct {
	ctrl     *gomock.Controller
	recorder *_MockerrorChannelRecorder
}

// Recorder for MockerrorChannel (not exported)
type _MockerrorChannelRecorder struct {
	mock *MockerrorChannel
}

func NewMockerrorChannel(ctrl *gomock.Controller) *MockerrorChannel {
	mock := &MockerrorChannel{ctrl: ctrl}
	mock.recorder = &_MockerrorChannelRecorder{mock}
	return mock
}

func (_m *MockerrorChannel) EXPECT() *_MockerrorChannelRecorder {
	return _m.recorder
}

func (_m *MockerrorChannel) Error() <-chan error {
	ret := _m.ctrl.Call(_m, "Error")
	ret0, _ := ret[0].(<-chan error)
	return ret0
}

func (_mr *_MockerrorChannelRecorder) Error() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Error")
}

func (_m *MockerrorChannel) Send(err error) bool {
	ret := _m.ctrl.Call(_m, "Send", err)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockerrorChannelRecorder) Send(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Send", arg0)
}

func (_m *MockerrorChannel) Receive() error {
	ret := _m.ctrl.Call(_m, "Receive")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockerrorChannelRecorder) Receive() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Receive")
}

// Mock of converter interface
type Mockconverter struct {
	ctrl     *gomock.Controller
	recorder *_MockconverterRecorder
}

// Recorder for Mockconverter (not exported)
type _MockconverterRecorder struct {
	mock *Mockconverter
}

func NewMockconverter(ctrl *gomock.Controller) *Mockconverter {
	mock := &Mockconverter{ctrl: ctrl}
	mock.recorder = &_MockconverterRecorder{mock}
	return mock
}

func (_m *Mockconverter) EXPECT() *_MockconverterRecorder {
	return _m.recorder
}

func (_m *Mockconverter) Convert(_param0 *amqp.Delivery) Message {
	ret := _m.ctrl.Call(_m, "Convert", _param0)
	ret0, _ := ret[0].(Message)
	return ret0
}

func (_mr *_MockconverterRecorder) Convert(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Convert", arg0)
}

// Mock of busRunner interface
type MockbusRunner struct {
	ctrl     *gomock.Controller
	recorder *_MockbusRunnerRecorder
}

// Recorder for MockbusRunner (not exported)
type _MockbusRunnerRecorder struct {
	mock *MockbusRunner
}

func NewMockbusRunner(ctrl *gomock.Controller) *MockbusRunner {
	mock := &MockbusRunner{ctrl: ctrl}
	mock.recorder = &_MockbusRunnerRecorder{mock}
	return mock
}

func (_m *MockbusRunner) EXPECT() *_MockbusRunnerRecorder {
	return _m.recorder
}

func (_m *MockbusRunner) Run(runtime *runtimeContext) {
	_m.ctrl.Call(_m, "Run", runtime)
}

func (_mr *_MockbusRunnerRecorder) Run(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Run", arg0)
}

// Mock of initializer interface
type Mockinitializer struct {
	ctrl     *gomock.Controller
	recorder *_MockinitializerRecorder
}

// Recorder for Mockinitializer (not exported)
type _MockinitializerRecorder struct {
	mock *Mockinitializer
}

func NewMockinitializer(ctrl *gomock.Controller) *Mockinitializer {
	mock := &Mockinitializer{ctrl: ctrl}
	mock.recorder = &_MockinitializerRecorder{mock}
	return mock
}

func (_m *Mockinitializer) EXPECT() *_MockinitializerRecorder {
	return _m.recorder
}

func (_m *Mockinitializer) initialize(_param0 *startupContext, _param1 *runtimeContext) {
	_m.ctrl.Call(_m, "initialize", _param0, _param1)
}

func (_mr *_MockinitializerRecorder) initialize(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "initialize", arg0, arg1)
}

// Mock of starter interface
type Mockstarter struct {
	ctrl     *gomock.Controller
	recorder *_MockstarterRecorder
}

// Recorder for Mockstarter (not exported)
type _MockstarterRecorder struct {
	mock *Mockstarter
}

func NewMockstarter(ctrl *gomock.Controller) *Mockstarter {
	mock := &Mockstarter{ctrl: ctrl}
	mock.recorder = &_MockstarterRecorder{mock}
	return mock
}

func (_m *Mockstarter) EXPECT() *_MockstarterRecorder {
	return _m.recorder
}

func (_m *Mockstarter) StartupContext(configuration *Configuration) (*startupContext, error) {
	ret := _m.ctrl.Call(_m, "StartupContext", configuration)
	ret0, _ := ret[0].(*startupContext)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockstarterRecorder) StartupContext(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "StartupContext", arg0)
}

func (_m *Mockstarter) RuntimeContext(parent context.Context) (*runtimeContext, error) {
	ret := _m.ctrl.Call(_m, "RuntimeContext", parent)
	ret0, _ := ret[0].(*runtimeContext)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockstarterRecorder) RuntimeContext(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "RuntimeContext", arg0)
}

func (_m *Mockstarter) NewBinder(routingKey string, handler Handler) {
	_m.ctrl.Call(_m, "NewBinder", routingKey, handler)
}

func (_mr *_MockstarterRecorder) NewBinder(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "NewBinder", arg0, arg1)
}

func (_m *Mockstarter) NewSender(replyTo string) Sender {
	ret := _m.ctrl.Call(_m, "NewSender", replyTo)
	ret0, _ := ret[0].(Sender)
	return ret0
}

func (_mr *_MockstarterRecorder) NewSender(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "NewSender", arg0)
}

func (_m *Mockstarter) Start(_param0 *startupContext, _param1 *runtimeContext) error {
	ret := _m.ctrl.Call(_m, "Start", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockstarterRecorder) Start(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Start", arg0, arg1)
}

// Mock of queueConsumer interface
type MockqueueConsumer struct {
	ctrl     *gomock.Controller
	recorder *_MockqueueConsumerRecorder
}

// Recorder for MockqueueConsumer (not exported)
type _MockqueueConsumerRecorder struct {
	mock *MockqueueConsumer
}

func NewMockqueueConsumer(ctrl *gomock.Controller) *MockqueueConsumer {
	mock := &MockqueueConsumer{ctrl: ctrl}
	mock.recorder = &_MockqueueConsumerRecorder{mock}
	return mock
}

func (_m *MockqueueConsumer) EXPECT() *_MockqueueConsumerRecorder {
	return _m.recorder
}

func (_m *MockqueueConsumer) Consume(runtime *runtimeContext, deliveries <-chan amqp.Delivery, handler handler) {
	_m.ctrl.Call(_m, "Consume", runtime, deliveries, handler)
}

func (_mr *_MockqueueConsumerRecorder) Consume(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Consume", arg0, arg1, arg2)
}

// Mock of senderLoop interface
type MocksenderLoop struct {
	ctrl     *gomock.Controller
	recorder *_MocksenderLoopRecorder
}

// Recorder for MocksenderLoop (not exported)
type _MocksenderLoopRecorder struct {
	mock *MocksenderLoop
}

func NewMocksenderLoop(ctrl *gomock.Controller) *MocksenderLoop {
	mock := &MocksenderLoop{ctrl: ctrl}
	mock.recorder = &_MocksenderLoopRecorder{mock}
	return mock
}

func (_m *MocksenderLoop) EXPECT() *_MocksenderLoopRecorder {
	return _m.recorder
}

func (_m *MocksenderLoop) Send(runtime *runtimeContext, channel upstream.Channel, sender sender) {
	_m.ctrl.Call(_m, "Send", runtime, channel, sender)
}

func (_mr *_MocksenderLoopRecorder) Send(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Send", arg0, arg1, arg2)
}

// Mock of handlerFactory interface
type MockhandlerFactory struct {
	ctrl     *gomock.Controller
	recorder *_MockhandlerFactoryRecorder
}

// Recorder for MockhandlerFactory (not exported)
type _MockhandlerFactoryRecorder struct {
	mock *MockhandlerFactory
}

func NewMockhandlerFactory(ctrl *gomock.Controller) *MockhandlerFactory {
	mock := &MockhandlerFactory{ctrl: ctrl}
	mock.recorder = &_MockhandlerFactoryRecorder{mock}
	return mock
}

func (_m *MockhandlerFactory) EXPECT() *_MockhandlerFactoryRecorder {
	return _m.recorder
}

func (_m *MockhandlerFactory) NewRequestHandler(runtime *runtimeContext, channel upstream.Channel, appHandler Handler) handler {
	ret := _m.ctrl.Call(_m, "NewRequestHandler", runtime, channel, appHandler)
	ret0, _ := ret[0].(handler)
	return ret0
}

func (_mr *_MockhandlerFactoryRecorder) NewRequestHandler(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "NewRequestHandler", arg0, arg1, arg2)
}

func (_m *MockhandlerFactory) NewReplyHandler(sender sender, channel upstream.Channel) handler {
	ret := _m.ctrl.Call(_m, "NewReplyHandler", sender, channel)
	ret0, _ := ret[0].(handler)
	return ret0
}

func (_mr *_MockhandlerFactoryRecorder) NewReplyHandler(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "NewReplyHandler", arg0, arg1)
}

// Mock of requestMap interface
type MockrequestMap struct {
	ctrl     *gomock.Controller
	recorder *_MockrequestMapRecorder
}

// Recorder for MockrequestMap (not exported)
type _MockrequestMapRecorder struct {
	mock *MockrequestMap
}

func NewMockrequestMap(ctrl *gomock.Controller) *MockrequestMap {
	mock := &MockrequestMap{ctrl: ctrl}
	mock.recorder = &_MockrequestMapRecorder{mock}
	return mock
}

func (_m *MockrequestMap) EXPECT() *_MockrequestMapRecorder {
	return _m.recorder
}

func (_m *MockrequestMap) Add(_param0 string, _param1 chan reply) {
	_m.ctrl.Call(_m, "Add", _param0, _param1)
}

func (_mr *_MockrequestMapRecorder) Add(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Add", arg0, arg1)
}

func (_m *MockrequestMap) Remove(_param0 string) bool {
	ret := _m.ctrl.Call(_m, "Remove", _param0)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockrequestMapRecorder) Remove(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Remove", arg0)
}

func (_m *MockrequestMap) Get(_param0 string) (chan reply, bool) {
	ret := _m.ctrl.Call(_m, "Get", _param0)
	ret0, _ := ret[0].(chan reply)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

func (_mr *_MockrequestMapRecorder) Get(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Get", arg0)
}

// Mock of sender interface
type Mocksender struct {
	ctrl     *gomock.Controller
	recorder *_MocksenderRecorder
}

// Recorder for Mocksender (not exported)
type _MocksenderRecorder struct {
	mock *Mocksender
}

func NewMocksender(ctrl *gomock.Controller) *Mocksender {
	mock := &Mocksender{ctrl: ctrl}
	mock.recorder = &_MocksenderRecorder{mock}
	return mock
}

func (_m *Mocksender) EXPECT() *_MocksenderRecorder {
	return _m.recorder
}

func (_m *Mocksender) OnReply(d amqp.Delivery) {
	_m.ctrl.Call(_m, "OnReply", d)
}

func (_mr *_MocksenderRecorder) OnReply(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "OnReply", arg0)
}

func (_m *Mocksender) Publish(channel upstream.Channel, request *upstream.Request) {
	_m.ctrl.Call(_m, "Publish", channel, request)
}

func (_mr *_MocksenderRecorder) Publish(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Publish", arg0, arg1)
}

func (_m *Mocksender) Outgoing() <-chan *send {
	ret := _m.ctrl.Call(_m, "Outgoing")
	ret0, _ := ret[0].(<-chan *send)
	return ret0
}

func (_mr *_MocksenderRecorder) Outgoing() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Outgoing")
}

func (_m *Mocksender) ReplyTo() string {
	ret := _m.ctrl.Call(_m, "ReplyTo")
	ret0, _ := ret[0].(string)
	return ret0
}

func (_mr *_MocksenderRecorder) ReplyTo() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "ReplyTo")
}

func (_m *Mocksender) ReplyChannel(correlationID string) <-chan reply {
	ret := _m.ctrl.Call(_m, "ReplyChannel", correlationID)
	ret0, _ := ret[0].(<-chan reply)
	return ret0
}

func (_mr *_MocksenderRecorder) ReplyChannel(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "ReplyChannel", arg0)
}

func (_m *Mocksender) Cleanup(correlationID string) bool {
	ret := _m.ctrl.Call(_m, "Cleanup", correlationID)
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MocksenderRecorder) Cleanup(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Cleanup", arg0)
}

// Mock of acker interface
type Mockacker struct {
	ctrl     *gomock.Controller
	recorder *_MockackerRecorder
}

// Recorder for Mockacker (not exported)
type _MockackerRecorder struct {
	mock *Mockacker
}

func NewMockacker(ctrl *gomock.Controller) *Mockacker {
	mock := &Mockacker{ctrl: ctrl}
	mock.recorder = &_MockackerRecorder{mock}
	return mock
}

func (_m *Mockacker) EXPECT() *_MockackerRecorder {
	return _m.recorder
}

func (_m *Mockacker) ack(_param0 *amqp.Delivery) error {
	ret := _m.ctrl.Call(_m, "ack", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockackerRecorder) ack(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "ack", arg0)
}
